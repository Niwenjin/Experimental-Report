# B+树
## B+树结构
![b+树](img\B+树结构.png)
B+树是一种多路搜索树，由分支节点和叶子节点构成。分支节点中只包含关键字和指向孩子节点的指针，叶子节点用于存储关键字和关键字指向的记录。m路B+树每个节点至少有⌈m/2⌉个关键字，至多有m个关键字，每个关键字对应一个指向孩子节点的指针。每个节点内部关键字从小到大排列，孩子节点的关键字范围为小于等于父节点关键字、大于父节点上一个关键字。
## B+树操作
### 查询
根据key值，从根节点开始寻找
* 非叶子节点，key值超出范围，查找失败
* 非叶子节点，根据索引的范围递归向下查找
* 叶子节点，找不到对应的key值，失败
* 叶子节点，找到key值对应的value值，成功
### 插入
从根节点开始，逐级查找插入的叶子节点位置
* 该叶子节点不满，直接插入
* 该叶子节点已满，进行分裂，将中间关键字提到父节点中，并将分裂的节点连接到父节点
* 若父节点已满，递归进行分裂，直到根节点
* 若根节点已满，分裂根节点，并将中间关键字提到新根节点中
### 删除
找到待删除关键字所在的叶子节点，删除该键值对
* 删除后关键字数量不小于最小值，直接删除
* 删除后关键字数量小于最小值，合并相邻的兄弟节点，此时父节点的关键字数量减少
* 父节点关键字数量小于最小值，继续合并
* 根节点只剩下1个关键字，删除根节点，将子节点作为新根节点
## 树结点类
成员变量  
* `bool`变量`isleaf`判断是否为叶子节点
* `size_t`变量`n`存储元素个数
* `vector<string>`存储key值
* `vector<string>`存储value值
* `vector<Node *>`存储指向孩子的指针
* `Node *`存储指向父母节点的指针
* `Node *`指向下一个叶子节点的指针
## B+树类
成员变量
* `size_t`变量`m`存储b+树的度
* `Node *`指向根节点的指针
* `Node *`指向首个叶子节点的指针
## 类方法
## 序列化与反序列化
## 测试用例
### 插入
在空树中插入一个元素
![插入空树](img\插入空树.png)  
在根节点中插入一个元素（不分裂）
![插入根节点](img\插入根节点1.png)
在根节点中插入一个元素（分裂）
![插入根节点](img\插入根节点2.png)
插入重复的元素
![重复插入](img\重复插入.png)
插入大于最大值的元素
![插入最大值](img\插入最大值.png)
插入叶子节点（不分裂）
![插入叶子](img\插入叶子.png)
插入叶子节点（只有叶子分裂）
![插入叶子](img\插入叶子2.png)
插入叶子节点（分支节点继续分裂）
![插入叶子](img\插入叶子3.png)
插入10000000个数据（乱序）
![大文件](img\大文件.png)
![大量插入](img\大量插入.png)
![大量插入](img\大量插入2.png)
### 删除
删除唯一的元素
![删除唯一](img\删除唯一.png)
删除元素（节点元素足够）
![删除元素](img\删除元素.png)
删除最大的元素
![删除元素](img\删除元素1.png)
删除元素（向兄弟节点借元素）
![删除元素](img\删除元素2.png)
删除元素（和兄弟节点合并）
![删除元素](img\删除元素3.png)
删除元素（合并后父节点元素不足，且父节点的兄弟有多余）
![删除元素](img\删除元素4.png)
删除元素（合并后父节点元素不足，且父节点的兄弟无多余）
![删除元素](img\删除元素5.png)
删除元素（合并后根节点只有一个元素）
![删除元素](img\删除元素6.png)
### 查询
查询存在的元素
![查询元素](img\查询.png)
查询不存在的元素
![查询元素](img\查询2.png)
### 修改
修改存在的元素
![修改元素](img\修改.png)
修改不存在的元素
![修改元素](img\修改2.png)