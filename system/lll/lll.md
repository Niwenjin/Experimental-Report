# 程序员的自我修养：链接、装载与库

## 目录

**第 1 部分 简介**  
第 1 章 温故而知新  
**第 2 部分 静态链接**  
[第 2 章 编译和链接](#第-2-章-编译和链接)  
[第 3 章 目标文件里有什么](#第-3-章-目标文件里有什么)  
[第 4 章 静态链接](#第-4-章-静态链接)  
第 5 章 Windows PE/COFF  
**第 3 部分 装载与动态链接**  
[第 6 章 可执行文件的装载与进程](#第-6-章-可执行文件的装载与进程)  
[第 7 章 动态链接](#第-7-章-动态链接)  
[第 8 章 Linux 共享库的组织](#第-8-章-linux-共享库的组织)  
第 9 章 Windows 下的动态链接  
**第 4 部分 库与运行库**  
第 10 章 内存  
第 11 章 运行库  
第 12 章 系统调用与 API  
第 13 章 运行库实现

## 第 2 章 编译和链接

将源代码编译成可执行文件的过程可以分解为 4 个步骤：预处理（Prepressing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。

**预处理**主要处理那些源代码文件中的以 “#” 开始的预编译指令，比如 “#include”、“#define” 等。预处理将源代码生成`.i`文件，相当于执行`$gcc –E hello.c –o hello.i`命令。主要处理规则如下：

-   将所有的 “#define” 删除，并且展开所有的宏定义。
-   处理所有条件预编译指令，比如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。
-   处理 “#include” 指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
-   删除所有的注释“//”和“/\* \*/”。
-   添加行号和文件名标识，比如#2“hello.c”2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。
-   保留所有的 #pragma 编译器指令，因为编译器须要使用它们。

**编译**过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。编译过程将生成`.s`文件，相当于执行`$gcc –S hello.i –o hello.s`命令。编译过程一般可以分为 6 步：词法分析、语法分析、语义分析、源代码优化、代码生成和目标代码优化。

-   词法分析：扫描器（Scanner）将源代码的字符序列分割成一系列的记号（Token），包括关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如加号、等号）。在识别记号的同时，扫描器也把标识符存放到符号表，将数字、字符串常量存放到文字表等。
-   语法分析：语法分析器（Grammar Parser）将对由扫描器产生的记号进行语法分析，从而产生语法树（Syntax Tree），就是以表达式（Expression）为节点的树。
-   语义分析：语义分析器（Semantic Analyzer）所能分析的语义是静态语义（Static Semantic），即在编译期可以确定的语义。静态语义通常包括声明和类型的匹配，类型的转换。经过语义分析阶段以后，整个语法树的表达式都被标识了类型。语义分析器还对符号表里的符号类型也做了更新。
-   源代码优化：源码级优化器（Source Code Optimizer）会在源代码级别进行优化。由于在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码（Intermediate Code），它是语法树的顺序表示。比较常见的有三地址码 `x = y op z`。
-   代码生成：代码生成器（Code Generator）将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。
-   目标代码优化：目标代码优化器（Target Code Optimizer）对目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。

**汇编**过程相对于编译器来讲比较简单，每一个汇编语句几乎都对应一条机器指令，只是根据汇编指令和机器指令的对照表一一翻译就可以了。汇编过程将生成`.o`文件，相当于执行`$gcc –c hello.c –o hello.o`命令。

**链接**过程将许多`.o`文件链接起来，生成最终的可执行程序`a.out`。链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤。

## 第 3 章 目标文件里有什么

目标文件和可执行文件可以被看作同一种文件类型，在 Windows 下是 PE（Portable Executable），在 Linux 下是 ELF（Executable Linkable Format），它们都是 COFF（Common file format）格式的变种。除了可执行文件和目标文件，动态链接库（Windows 的.dll 和 Linux 的.so）及及静态链接库（Windows 的.lib 和 Linux 的.a）也按照可执行文件格式存储。

目标文件中的内容至少有编译后的机器指令代码、数据。除此之外，目标文件中还包括了链接时所须要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“节”（Section）的形式存储，有时候也叫“段”（Segment）。

<img src="img/3-1.png" height=400><img src="img/3-2.png" height=400>

如图，ELF 格式的可执行文件中，开头是一个“**文件头**”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息。紧接着是 ELF 文件各个段。接下来还包括一个**段表**（Section Table），段表是描述了文件中各个段在文件中的偏移位置及段的属性等信息的数组。

### 文件头

ELF 的文件头中定义了 ELF 魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI 版本、ELF 重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。

-   ELF 魔数：最开始的 4 个字节被称为魔数，所有 ELF 文件都有相同的标识码，分别为 0x7F、0x45、0x4c、0x46。

    _几乎所有可执行文件的开头几个字节都是魔数。_

-   文件机器字节长度：接下来的 1 个字节用来标识 ELF 文件的字长，，0x01 表示是 32 位；0x02 表示是 64 位。
-   数据存储方式：第 6 个字节表示字节序，规定该 ELF 是大端还是小端。
-   版本：第 7 个字节规定 ELF 文件的主版本号，一般是 1。
-   入口地址：规定 ELF 程序的入口虚拟地址。
-   段表的位置：记录了段表的开始位置在文件中的偏移。

### 代码段

程序源代码编译后的机器指令经常被放在**代码段**（Code Section）里，代码段常见的名字有“.code”或“.text”；全局变量和局部静态变量数据经常放在**数据段**（Data Section），一般叫“.data”。C 语言的编译后执行语句都编译成机器代码，保存在 “.text” 代码段；已初始化的全局变量和局部静态变量都保存在 “.data” 段；未初始化的全局变量和局部静态变量一般放在一个叫 “.bss” 的段里，它为未初始化的变量预留位置，并没有内容，在文件中也不占用空间。

把程序的指令和数据的存放分开有许多好处：一方面是当程序被装载后，数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读，可以防止程序的指令被有意或无意地改写；另外一方面是指令区和数据区的分离有利于提高程序的局部性，有利于提高缓存的命中率；第三个原因，也是最重要的原因，就是当系统中运行着多个该程序的副本时，数据区域是私有的，但是指令区域可以是共享的，所以内存中只需要保存一份进程的指令部分。

ELF 文件中实际存在的就是“.text”、“.data”、“.rodata”和“.comment”这 4 个段。“.text”段存放指令的机器代码；“.data”段存放已初始化的全局变量和局部静态变量，未初始化的变量则声明在“.bbs”段中，不占用空间；“.rodata”段存放的是只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量；“.comment”段中存储的是编译器版本信息。

### 段表

段表（Section Header Table）是保存了 ELF 文件中各种段的基本属性的结构。段表是 ELF 文件中除了文件头以外最重要的结构，它描述了 ELF 的各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。

段表的结构比较简单，它是一个以“Elf32_Shdr”结构体为元素的数组。数组元素的个数等于段的个数，每个“Elf32_Shdr”结构体对应一个段。“Elf32_Shdr”又被称为段描述符（Section Descriptor）。结构体定义如下：

```c
typedef struct
{
    Elf32_Word sh_name;       // 段名
    Elf32_Word sh_type;       // 段类型
    Elf32_Word sh_flags;      // 标识位
    Elf32_Addr sh_addr;       // 段虚拟地址
    Elf32_Off sh_offset;      // 段偏移（在文件中的偏移）
    Elf32_Word sh_size;       // 段长度
    Elf32_Word sh_link;       // 段链接信息
    Elf32_Word sh_info;       // 段链接信息
    Elf32_Word sh_addralign;  // 段地址对齐
    Elf32_Word sh_entsize;    // Section Entry Size 项的长度
} Elf32_Shdr;
```

### 重定位表

链接器在处理目标文件时，须要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些重定位的信息都记录在 ELF 文件的重定位表里面，对于每个须要重定位的代码段或数据段，都会有一个相应的重定位表。

### 字符串表

因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。

### 符号表

在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。

符号是链接中的粘合剂，整个链接过程正是基于符号才能够正确完成。链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。

ELF 文件中的符号表往往是文件中的一个段，段名一般叫“.symtab”。符号表的结构是一个 Elf32_Sym 结构（32 位 ELF 文件）的数组，每个 Elf32_Sym 结构对应一个符号。结构体定义如下：

```c
typedef struct {
    Elf32_Word st_name;      // 符号名。这个成员包含了该符号名在字符串表中的下标。
    Elf32_Addr st_value;     // 符号对应的值
    Elf32_Word st_size;      // 符号大小。对于包含数据的符号，这个值是数据类型的大小。
    unsigned char st_info;   // 符号类型和绑定信息
    unsigned char st_other;  // 0
    Elf32_Half st_shndx;     // 符号所在的段
} Elf32_Sym;
```

_像 C++这样的后来设计的语言开始考虑到命名冲突问题，增加了名称空间（Namespace）的方法来解决多模块的符号冲突问题。_

### 调试信息

如果在编译时加上 -g 参数，就会发现，目标文件里多了很多 “debug” 相关的段，这些段中保存的就是调试信息。调试信息在目标文件和可执行文件中占用很大的空间，往往比程序的代码和数据本身大好几倍。

## 第 4 章 静态链接

现代的链接器一般都采用一种叫两步链接（Two-pass Linking）的方法。第一步，**空间与地址分配**，扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。第二步，**符号解析与重定位**，使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。

### 空间与地址分配

对于链接器来说，整个链接过程中，它就是将几个输入目标文件加工后合并成一个输出文件。对于多个目标文件，链接器将相同性质的段合并到一起，比如将所有输入文件的“.text”合并到输出文件的“.text”段，接着是“.data”段、“.bss”段等。

为目标文件分配地址和空间有两个含义：第一个是在输出的可执行文件中的空间；第二个是在装载后的虚拟地址中的虚拟地址空间。对于有实际数据的段，比如“.text”和“.data”来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于“.bss”这样的段来说，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。

VMA 表示 Virtual Memory Address，即虚拟地址。在链接之前，目标文件中的所有段的 VMA 都是 0。经过链接，VMA 才被确定下来，链接后的程序中所使用的地址已经是程序在进程中的虚拟地址。

在扫描和空间地址分配阶段，链接器按照操作系统的虚拟地址空间的分配规则，确认每段的起始地址。完成后，链接器开始计算各个符号的虚拟地址，即给每个符号加上一个偏移量。

### 符号解析与重定位

在完成空间和地址的分配步骤以后，链接器就进入了符号解析与重定位的步骤，这也是静态链接的核心内容。

在完成地址和空间分配之后，就已经可以确定所有符号的虚拟地址了，链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。在 ELF 文件中，维护了重定位表（Relocation Table）来保存与重定位相关的信息。每一个需要重定位的段都有一个对应的重定位表，比如代码段“.text”中有需要重定位的符号，就会维护一个“.rel.text”段保存了代码段的重定位表。重定位表的结构如下：

```c
typedef struct {
    Elf32_Addr r_offset;  // 重定位入口的偏移
    Elf32_Word r_info;    // 重定位入口的类型和符号
} Elf32_Rel;
```

每个要被重定位的地方被称为重定位入口（Relocation Entry），每个重定位的入口都是对一个符号的引用。链接器会查找由所有输入目标文件的符号表组成的*全局符号表*，找到相应的符号后进行重定位。

### 静态库链接

链接器在链接静态库的时候是以目标文件为单位的。在一般的情况下，一种语言的开发环境往往会附带有语言库（Language Library），这些库就是对操作系统的 API 的封装，也叫静态运行库。每个静态运行库都是许多 .o 目标文件封装而成的，每个目标文件只包含一个函数，例如 libc.a 中，printf.o 目标文件中只包含了 printf() 函数。链接静态库时，ld 链接器会寻找需要的符号及它们所在的目标文件，将 .a 文件中的这些目标文件解压出来，最终将它们链接起来成为一个可执行文件。

## 第 6 章 可执行文件的装载与进程

可执行文件只有装载到内存才能被 cpu 执行。随着硬件 MMU 的诞生，多进程、多用户、虚拟存储的操作系统出现以后，可执行文件的装载过程变得非常复杂。

### 装载的方式

程序执行时所需要的指令和数据必须在内存中才能够正常运行，最简单的办法就是将程序运行所需要的指令和数据全都装入内存中，这就是**静态装入**的办法。由于程序运行时的局部性原理，可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里，这种方式被称为**动态装入**。覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法。

覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序的时候必须手工将程序分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存而何时应该被替换掉。这个小的辅助代码就是所谓的覆盖管理器（Overlay Manager）。

_覆盖装入在没有发明虚拟存储之前使用比较广泛，现在已经几乎被淘汰了。_

**页映射**是虚拟存储机制的一部分，它随着虚拟存储的发明而诞生。操作系统的存储管理器将物理内存和程序中的数据和指令按照“页（Page）”为单位划分成若干个页，作为以后所有的装载和操作的最小单位。当虚拟地址被访问时，存储管理器为程序分配一个内存页，将程序中对应的页装入内存页中。由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件（Image）。一旦被装载，可执行文件与执行该可执行文件进程的虚拟空间就产生了映射关系，操作系统用一个数据结构保存这种映射关系。

### 进程虚存空间分布

Linux 中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA, Virtual Memory Area）。ELF 文件中有许多段，操作系统只关心和装载相关的问题，最主要的是段的权限，基本有三种：

-   以代码段为代表的权限为可读可执行的段。
-   以数据段和 BSS 段为代表的权限为可读可写的段。
-   以只读数据段为代表的权限为只读的段。

对于相同权限的段“Section”，可以把它们合并到一起，成为一个“Segment”，映射到一个 VMA 中，这样可以减少页面内部碎片，从而节省内存空间。ELF 可执行文件中有一个专门的数据结构叫做程序头表（Program Header Table）用来保存“Segment”的信息。程序头表也是一个结构体数组，它的结构体如下：

```c
typedef struct {
    Elf32_Word p_type;    // “Segment” 的类型
    Elf32_Off p_offset;   // “Segment” 在ELF文件中的偏移
    Elf32_Addr p_vaddr;   // “Segment” 在虚拟地址空间中的偏移
    Elf32_Addr p_paddr;   // “Segment” 的物理装载地址
    Elf32_Word p_filesz;  // “Segment” 在ELF文件中占用空间的长度
    Elf32_Word p_memsz;   // “Segment” 在虚拟空间中占用空间的长度
    Elf32_Word p_flags;   // “Segment” 的权限属性，如可读“R”
    Elf32_Word p_align;   // “Segment” 的对齐属性
} Elf32_Phdr;
```

VMA 除了被用来映射可执行文件中的各个“Segment”以外，还被用来对进程的地址空间进行管理。事实上，进程的栈（Stack）、堆（Heap）等空间也是以 VMA 的形式存在的。一个进程基本上可以分为如下几种 VMA 区域：

-   代码 VMA，权限只读、可执行；有映像文件。
-   数据 VMA，权限可读写、可执行；有映像文件。
-   堆 VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展。
-   栈 VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展。

### Linux 内核装载 ELF 过程

Linux 通过文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。在用户层面，bash 进程会调用 fork()系统调用创建一个新的进程，然后新的进程调用 execve() 系统调用执行指定的 ELF 文件。在内核中， execve() 系统调用相应的入口是 sys_execve()，sys_execve() 进行一些参数的检查复制之后，调用 do_execve()。do_execve() 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。读取了这 128 个字节的文件头部之后，然后调用 search_binary_handle() 去搜索和匹配合适的可执行文件装载处理过程。

ELF 可执行文件对应的装载方法是 load_elf_binary() 函数，步骤如下：

1. 检查 ELF 可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量；
2. 寻找动态链接的“.interp”段，设置动态链接器路径（见第 9 章）；
3. 根据 ELF 可执行文件的程序头表的描述，对 ELF 文件进行映射，比如代码、数据、只读数据；
4. 初始化 ELF 进程环境，比如进程启动时 EDX 寄存器的地址应该是 DT_FINI 的地址；
5. 将系统调用的返回地址修改成 ELF 可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的 ELF 可执行文件，这个程序入口就是 ELF 文件的文件头中 e_entry 所指的地址；对于动态链接的 ELF 可执行文件，程序入口点是动态链接器。

当 load_elf_binary() 执行完毕，返回至 do_execve() 再返回至 sys_execve() 时，上面的第 5 步中已经把系统调用的返回地址改成了被装载的 ELF 程序的入口地址了。所以当 sys_execve() 系统调用从内核态返回到用户态时，EIP 寄存器直接跳转到了 ELF 程序的入口地址，于是新的程序开始执行，ELF 可执行文件装载完成。

## 第 7 章 动态链接

静态连接的方式对于计算机内存和磁盘的空间浪费非常严重，尤其是在多进程操作系统情况下。另一个问题是静态链接对程序的更新、部署和发布产生困难，任何一个静态链接库的更新都需要重新链接整个程序。

为了解决以上两个问题，可以把链接这个过程推迟到运行时再执行，这就是动态链接（Dynamic Linking）的基本思想。这种做法解决了共享的目标文件多个副本浪费磁盘和内存空间的问题，也使程序兼具可扩展性和兼容性。

动态链接涉及运行时的链接及多个文件的装载，必需要有操作系统的支持，因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。在 Linux 系统中，ELF 动态链接文件被称为动态共享对象（DSO，Dynamic Shared Objects），简称共享对象，它们一般都是以“.so”为扩展名的一些文件；而在 Windows 系统中，动态链接文件被称为动态链接库（Dynamical Linking Library），它们通常是以“.dll”为扩展名的文件。

### 地址无关代码

在静态链接时，整个程序最终只有一个可执行文件，它是一个不可以分割的整体；但是在动态链接下，一个程序被分成了若干个文件，包括可执行文件（Program1）和程序所依赖的共享对象（Lib.so），很多时候我们也把这些部分统称为模块。

程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PIC, Position-independent Code）的技术。

为了实现模块间数据访问，ELF 的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表（Global Offset Table，GOT），当代码需要引用该全局变量时， 可以通过 GOT 中相对应的项间接引用。当指令中需要访问变量 b 时，程序会先找到 GOT，然后根据 GOT 中变量所对应的项找到变量的目标地址。

### 动态链接相关结构

在动态链接的情况下，映射完可执行文件之后，可执行文件里对于很多外部符号的引用还处于无效地址的状态，此时操作系统需要启动一个动态链接器（Dynamic Linker）。在 Linux 下，动态链接器 ld.so 实际上是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间中。当所有动态链接工作完成以后，动态链接器会将控制权转交到可执行文件的入口地址，程序开始正式执行。

在动态链接的 ELF 可执行文件中，有一个专门的段叫做“.interp”段，保存了可执行文件所需要的动态链接器的路径，用于寻找指定的共享对象。类似于“.interp”这样的段，ELF 中还有几个段也是专门用于动态链接的，比如“.dynamic”段和“.dynsym”段等。

动态链接 ELF 中最重要的结构应该是“.dynamic”段，这个段里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。“.dynamic”段的结构数组定义在“elf.h”中：

```c
typedef struct {
    Elf32_Sword d_tag;
    union {
        Elf32_Word d_val;
        Elf32_Addr d_ptr;
    } d_un;
} Elf32_Dyn;
```

为了完成动态链接，最关键的还是所依赖的符号和相关文件的信息。为了表示动态链接这些模块之间的符号导入导出关系，ELF 专门有一个叫做动态符号表（Dynamic Symbol Table）的段用来保存这些信息，通常叫做“.dynsym”（Dynamic Symbol）。“.dynsym”只保存了与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。

动态链接下，无论是可执行文件或共享对象，一旦它依赖于其他共享对象，那么它的代码或数据中就会有对于导入符号的引用，即需要重定位。动态链接的文件中，重定位表分别叫做 “.rel.dyn” 和 “.rel.plt” ，它们分别相当于静态链接中的 “.rel.text” 和 “.rel.data” 。 “.rel.dyn” 实际上是对数据引用的修正，它所修正的位置位于 “.got” 以及数据段；而 “.rel.plt” 是对函数引用的修正，它所修正的位置位于“.got.plt”。

### 动态链接的步骤和实现

动态链接的步骤基本上分为 3 步：先是启动动态链接器本身，然后装载所有需要的共享对象，最后是重定位和初始化。

道动态链接器本身也是一个共享对象，但是具有一些特殊性。动态链接器本身不可以依赖于其他任何共享对象；动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成。因此动态链接器在启动时要调用一段特殊的代码进行自举（Bootstrap）。动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的 GOT。而 GOT 的第一个入口保存的即是“.dynamic”段的偏移地址，由此找到了动态连接器本身的“.dynamic”段。通过“.dynamic”中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。从这一步开始，动态链接器代码中才可以开始使用自己的全局变量和静态变量。

完成基本自举以后，动态链接器将可执行文件和链接器本身的符号表都合并全局符号表（Global Symbol Table）中，然后链接器开始寻找可执行文件所依赖的共享对象。链接器可以列出可执行文件所需要的所有共享对象集合。然后链接器开始从集合里取一个所需要的共享对象的文件，读取相应的 ELF 文件头和“.dynamic”段，然后将它相应的代码段和数据段映射到进程空间中。如果这个 ELF 共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名字放到装载集合中，如此循环直到所有依赖的共享对象都被装载进来为止。每个共享对象被装载时，它的符号表会都被合并到全局符号表中，当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要的符号。

装载完成后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的 GOT/PLT 中的每个需要重定位的位置进行修正。当完成了重定位和初始化之后，动态链接器将进程的控制权转交给程序的入口并且开始执行。

## 第 8 章 Linux 共享库的组织

大多数包括 Linux 在内的开源操作系统都遵守一个叫做 FHS（File Hierarchy Standard）的标准，这个标准规定了一个系统中的系统文件应该如何存放，包括各个目录的结构、组织和作用。FHS 规定，系统中存放共享库的位置如下：

-   /lib，这个位置主要存放系统最关键和基础的共享库，比如动态链接器、C 语言运行库、数学库等，这些库主要是那些/bin 和/sbin 下的程序所需要用到的库，还有系统启动时需要的库。
-   /usr/lib，这个目录下主要保存的是一些非系统运行时所需要的关键性的共享库，主要是一些开发时用到的共享库。这个目录下面还包含了开发时可能会用到的静态库、目标文件等。
-   /usr/local/lib，这个目录用来放置一些跟操作系统本身并不十分相关的库，主要是一些第三方的应用程序的库。

动态链接器在查找共享库时，会在在/lib、/usr/lib 和由/etc/ld.so.conf 配置文件指定的目录中查找共享库。为了程序的可移植性和兼容性，共享库的路径往往是相对的。

Linux 使用 ldconfig 程序来维护共享库文件的缓存，位置在/etc/ld.so.cache，便于共享库的查找，因此理论上讲，如果在系统制定的共享库目录下添加、删除或更新任何一个共享库，或更改了/etc/ld.so.conf 配置文件,都应该运行 ldconfig。
