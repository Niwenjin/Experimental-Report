# Effective Modern C++

## 目录

[第 1 章 型别推导](#型别推导)  
[第 2 章 auto](#auto)  
[第 3 章 转向现代 C++](#转向现代-c)  
[第 4 章 智能指针](#智能指针)  
[第 5 章 右值引用、移动语义和完美转发](#右值引用移动语义和完美转发)  
[第 6 章 lambda 表达式](#lambda表达式)  
[第 7 章 并发 API](#并发-api)  
[第 8 章 微调](#微调)

## 型别推导

### 条款 1：理解模板型别推导

规则：

- 在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。
- 对万能引用形参进行推导时，左值实参会进行特殊处理。
- 对按值传递的形参进行推导时，若实参型别中带有 const 或 volatile 饰词，则它们还是会被当作不带 const 或 volatile 饰词的型别来处理。
- 在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。

### 条款 2：理解 auto 型别推导

- 在一般情况下，auto 型别推导和模板型别推导是一模一样的，但是 auto 型别推导会假定用大括号括起的初始化表达式代表一个 td::initializer_list。
- C++14 允许在函数返回值或 lambda 式的形参中使用 auto, 意思是使用模板型别推导而非 auto 型别推导。

### 条款 3：理解 decltype

- 绝大多数情况下，decltype 会得出变量或表达式的型别而不作任何修改。
- 对于型别为 T 的左值表达式，除非该表达式仅有一个名字，decltype 总是得出型别 T&。
- C++l4 支持 decltype(auto)，和 auto 一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是 decltype 的规则。

### 条款 4：掌握查看型别推导结果的方法

- 利用 IDE 编辑器、编译器错误消息、typeid().name 和 Boost.Typelndex 库常常能够查看到推导而得的型别。
- 有些工具产生的结果可能会无用，或者不准确。所以，理解 C++ 型别推导规则是必要的。

## auto

### 条款 5：优先选用 auto，而非显式型别声明

- auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别要少打一些字。

### 条款 6：当 auto 推导的型别不符合要求时，使用带显式型别的初始化物习惯用法

- “隐形”的代理型别可以导致 auto 根据初始化表达式推导出错误的型别。

## 转向现代 C++

### 条款 7：在创建对象时注意区分()和{}

- 大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫。
- 在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有 std::initializer_list 型别的形参相匹配，即使其他重载版本有着更加匹配的形参表。
- 使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个 std::vector<数值型别>对象。

### 条款 8：优先选用 nullptr，而非 0 或 NULL

### 条款 9：优先选用别名声明，而非 typedef

C++11 提供了别名声明：

```cpp
using UPtrMapSS =
  std::unique_ptr<std::unordered_map<std::string, std::string>>;
```

### 条款 10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别

- 用 enum class 替代 enum。

### 条款 11：优先选用删除函数，而非 private 未定义函数

在 C++11 中，使用“=delete”将需要阻止调用的函数标识为删除函数。任何函数都可以删除，包括非成员函数和模板具现。

```cpp
class Widget {
  public:
    // 阻止调用拷贝构造函数
    Widget(const Widget&) = delete;
    Widget& operator=(const Widget&) = delete;
}
```

### 条款 12：为改写的函数添加 override 声明

### 条款 13：优先选用 const_iterator，而非 iterator

### 条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明

### 条款 15：尽可能使用 constexpr

- constexpr 对象都具备 const 属性，并由编译期已知的值完成初始化。
- constexpr 函数在调用时若传入的实参值是编译期已知的，则会产出编译期结果。
- 比起非 constexpr 对象或 constexpr 函数，constexpr 对象或是 constexpr 函数可以用在一个作用域更广的语境中。

### 条款 16：保证 const 成员函数的线程安全性

- 保证 const 成员函数的线程安全性，除非可以确信它们不会用在并发语境中。
- 运用 std::atomic 型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作。

### 条款 17：理解特种成员函数的生成机制

特种成员函数是指那些 C+＋会自行生成的成员函数。C++11 中，支配特种成员函数的机制如下：

- 默认构造函数：与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时才生成。
- 析构函数：与 C++98 的机制基本相同，唯一的区别在千析构函数默认为 noexcept。与 C++98 的机制相同，仅当基类的析构函数为虚的，派生类的析构函数才是虚的。
- 拷贝构造函数：运行期行为与 C++98 相同：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为。
- 拷贝赋值运算符：运行期行为与 C++98 相同：按成员进行非静态数据成员的复制赋值。仅当类中不包含用户声明的复制赋值运算符时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制构造函数或析构函数的条件下，仍然生成复制赋值运算符已经成为了被废弃的行为。
- 移动构造函数和移动赋值运算符：都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。

## 智能指针

### 条款 18：使用 std::unique_ptr 管理具备专属所有权的资源

### 条款 19：使用 std::shared_ptr 管理具备共享所有权的资源

### 条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr

### 条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new

### 条款 22: 使用 Pimpl 习惯用法时，将特殊成员函数的定义放到实现文件中

- Pimpl 惯用法通过降低类的客户和类实现者之间的依赖性，减少了构建遍数。
- 对于采用 std::unique_ptr 来实现的 pimpl 指针，须在类的头文件中声明特种成员函数，但在实现文件中实现它们，即使默认函数实现有着正确行为也必须这样做。

## 右值引用、移动语义和完美转发

### 条款 23：理解 std::move 和 std::forward

### 条款 24：区分万能引用和右值引用

- 如果函数模板形参具备 T&& 型别，并且 T 的型别系推导而来，或如果对象使用 auto&& 声明其型别，则该形参或对象就是个万能引用。
- 如果型别声明并不精确地具备 type&& 的形式，或者型别推导并未发生，则 type&& 就代表右值引用。
- 若采用右值来初始化万能引用，就会得到一个右值引用；若采用左值来初始化万能引用，就会得到一个左值引用。

### 条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward

### 条款 26：避免依万能引用型别进行重载

### 条款 27：熟悉依万能引用型别进行重载的替代方案

### 条款 28：理解引用折叠

### 条款 29：假定移动操作不存在、成本高、未使用

### 条款 30：熟悉完美转发的失败情形

## lambda 表达式

### 条款 31：避免默认捕获模式

### 条款 32：使用初始化捕获将对象移入闭包

使用 C++14 的初始化捕获将对象移入闭包：

```cpp
auto pw = std::make_unique<Wiget>();
auto func = [pw = std::move(pw)]
            {
              return pw->isValidated();
            };
```

### 条款 33：对 auto&&型别的形参使用 decltype，以 std::forward 之

### 条款 34：优先选用 lambda 式，而非 std::bind

## 并发 API

### 条款 35：优先选用基于任务而非基于线程的程序设计

### 条款 36：如果异步是必要的，则指定 std::launch::async

### 条款 37：使 std::thread 型别对象在所有路径皆不可联结

### 条款 38：对变化多端的线程句柄析构函数行为保持关注

### 条款 39：考虑针对一次性事件通信使用以 void 为模板型别实参的期值

### 条款 40：对并发使用 std::atomic，对特种内存使用 volatile

- std::atomic 用于多线程访问的数据，且不用互斥量。它是撰写并发软件的工具。
- volatile 用于读写操作不可以被优化掉的内存。它是在面对特种内存时使用的工具。

## 微调

### 条款 41: 针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递

### 条款 42：考虑置入而非插入

置入函数（emplace/emplace_back 等）在以下几个前提成立时，比插入函数（insert/push_back 等）运行得更快：

1. 待添加的值是以构造而非赋值方式加入容器；
2. 传递的实参型别与容器持有之物的型别不同；
3. 容器不会由于存在重复值而拒绝待添加的值。
