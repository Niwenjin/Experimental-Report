# 深入理解计算机系统

## 目录

[第 1 章 计算机系统漫游](#第1章-计算机系统漫游)  
**第一部分 程序结构和执行**  
[第 2 章 信息的表示和处理](#第2章-信息的表示和处理)  
[第 3 章 程序的机器级表示](#第3章-程序的机器级表示)  
[第 4 章 处理器体系结构](#第4章-处理器体系结构)  
[第 5 章 优化程序性能](#第5章-优化程序性能)  
[第 6 章 存储器层次结构](#第6章-存储器层次结构)  
**第二部分 在系统上运行程序**  
[第 7 章 链接](#第7章-链接)  
[第 8 章 异常控制流](#第8章-异常控制流)  
[第 9 章 虚拟内存](#第9章-虚拟内存)  
**第三部分 程序间的交互和通信**  
[第 10 章 系统级 I/O](#第10章-系统级io)  
[第 11 章 网络编程](#第11章-网络编程)  
[第 12 章 并发编程](#第12章-并发编程)

## 第 1 章 计算机系统漫游

计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。系统不仅仅只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。

系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。

处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/0 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构 CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。

操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：

1. 文件是对 I/0 设备的抽象；
2. 虚拟内存是对主存和磁盘的抽象；
3. 进程是处理器、主存和 I/0 设备的抽象。

最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/0 设备。

Gene Amdahl，计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。这个观察被称为 Amdahl 定律(Amdahl's law)。假设系统某部分所需执行时间与该时间的比例为 α，而该部分性能提升比例为 k。加速比 S 为：

$$
S = \frac{1}{(1 - \alpha) + \alpha / k}
$$

## 第 2 章 信息的表示和处理

现代计算机存储和处理的信息以二进制信号（位，bit）表示。我们研究三种最重要的数字表示。

-   无符号（unsigned）编码：基于传统的二进制表示法，表示大于或者等于零的数字。
-   补码（two's-complement）编码：表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。
-   浮点数（floating-point）编码：表示实数的科学记数法的以 2 为基数的版本。

### 信息存储

大多数计算机使用 8 位的块，或者宇节 (byte)，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存 (virtual memory)。内存的每个字节都由一个唯一的数字来标识，称为它的地址(address)，所有可能地址的集合就称为虚拟地址空间 (virtual address space) 。

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。某些机器选择在内存中按照*从最低有效字节到最高有效字节*的顺序存储对象，而另一些机器则按照*从最高有效字节到最低有效字节*的顺序存储。前一种规则——最低有效字节在最前面的方式，称为小端法 (little endian)。后一种规则—-—最高有效字节在最前面的方式，称为大端法 (big endian)。

例如，对于一个十六进制为 0x1234567 的变量，它在大端和小端机器上的存储方式为：

| 内存地址 | 0x100 | 0x101 | 0x102 | 0x103 |
| -------- | ----- | ----- | ----- | ----- |
| 大端法   | 01    | 23    | 45    | 67    |
| 小端法   | 67    | 45    | 23    | 01    |

对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的，无论为哪种类型的机器所编译的程序都会得到同样的结果。不过在以下情景，字节顺序会成为问题：

1. 不同类型的机器之间通过网络传送二进制数据时；
2. 反汇编器生成指令序列时；
3. 使用强制类型转换来访问和打印不同程序对象的字节表示时。

### 整数表示

C 语言默认支持无符号数和有符号数，无符号数用二进制数表示，有符号数用二进制数的补码编码表示。

-   原码：直接用二进制数表示一个数。在原码中，最高位是符号位，0 表示正数，1 表示负数。
-   反码：对于正数，其反码与其原码相同。对于负数，其反码是将原码*除符号位外*的所有位取反。
-   补码：对于正数，其补码与其原码相同。对于负数，其补码是其反码加 1。

从一个较小的数据类型转换到一个较大的类型称为**扩展**。对于无符号数，只需要在二进制表示的开头添加 0，这种运算被称为**零扩展**。对于补码数，需要执行**符号扩展**，即在开头复制符号位的值。

从一个较大的数据类型转换到一个较小的类型称为**截断**。此时只会保留低位的二进制表示，可能会发生溢出，导致数值改变。

### 整数运算

### 浮点数

浮点数及其运算的标准由 IEEE 754 标准规定。IEEE 浮点标准用$V = (-1)^{s} × M × 2^E$的形式表示一个数：

-   符号：s 决定负数(1)还是正数(0)。
-   尾数：M 是一个二进制小数，它的范围是 1~2-$\epsilon$，或者 0~1-$\epsilon$。
-   阶码：E 的作用是对浮点数加权，这个权重是 2 的 E 次幂（可以是负数）。

将浮点数的位表示划分为三个字段，分别对这些值进行编码：

-   一个单独的符号位 s。
-   k 位的阶码字段 exp 编码阶码 E。
-   n 位的小数字段 frac 编码尾数 M。

在单精度浮点格式中，上述字段分别为 s=1, k=8, n=23 位，得到一个 32 位的表示。在双精度浮点格式中，则分别为 s=1, k=11, n=52 位，得到一个 64 位的表示。

<img src="img/2-32.png" width=450>

_非规格化数：当阶码全为 0 时，所表示的数是非规格化形式。这种数可以表示数值 0；另一个功能是表示非常接近 0 的数。_

_特殊值：当阶码全为 1 时，表示特殊值。此时，若小数全为 0，代表无穷，当 s=0 时为正无穷，当 s=1 时为负无穷；当小数为非零时，结果值被称为 NaN，可用于表示非法运算结果或未初始化的数据等。_

## 第 3 章 程序的机器级表示

计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后编译器调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

## 第 7 章 链接

链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在现代系统中，链接是由链接器（linker）程序自动执行的。

## 第 9 章 虚拟内存
