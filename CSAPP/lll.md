# 程序员的自我修养：链接、装载与库

## 目录

**第 1 部分 简介**  
第 1 章 温故而知新  
**第 2 部分 静态链接**  
[第 2 章 编译和链接](#第-2-章-编译和链接)  
[第 3 章 目标文件里有什么](#第-3-章-目标文件里有什么)  
[第 4 章 静态链接](#第-4-章-静态链接)  
第 5 章 Windows PE/COFF  
**第 3 部分 装载与动态链接**  
第 6 章 可执行文件的装载与进程  
第 7 章 动态链接  
第 8 章 Linux 共享库的组织  
第 9 章 Windows 下的动态链接  
**第 4 部分 库与运行库**  
第 10 章 内存  
第 11 章 运行库  
第 12 章 系统调用与 API  
第 13 章 运行库实现

## 第 2 章 编译和链接

将源代码编译成可执行文件的过程可以分解为 4 个步骤：预处理（Prepressing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。

**预处理**主要处理那些源代码文件中的以 “#” 开始的预编译指令，比如 “#include”、“#define” 等。预处理将源代码生成`.i`文件，相当于执行`$gcc –E hello.c –o hello.i`命令。主要处理规则如下：

-   将所有的 “#define” 删除，并且展开所有的宏定义。
-   处理所有条件预编译指令，比如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。
-   处理 “#include” 指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
-   删除所有的注释“//”和“/\* \*/”。
-   添加行号和文件名标识，比如#2“hello.c”2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。
-   保留所有的 #pragma 编译器指令，因为编译器须要使用它们。

**编译**过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。编译过程将生成`.s`文件，相当于执行`$gcc –S hello.i –o hello.s`命令。编译过程一般可以分为 6 步：词法分析、语法分析、语义分析、源代码优化、代码生成和目标代码优化。

-   词法分析：扫描器（Scanner）将源代码的字符序列分割成一系列的记号（Token），包括关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如加号、等号）。在识别记号的同时，扫描器也把标识符存放到符号表，将数字、字符串常量存放到文字表等。
-   语法分析：语法分析器（Grammar Parser）将对由扫描器产生的记号进行语法分析，从而产生语法树（Syntax Tree），就是以表达式（Expression）为节点的树。
-   语义分析：语义分析器（Semantic Analyzer）所能分析的语义是静态语义（Static Semantic），即在编译期可以确定的语义。静态语义通常包括声明和类型的匹配，类型的转换。经过语义分析阶段以后，整个语法树的表达式都被标识了类型。语义分析器还对符号表里的符号类型也做了更新。
-   源代码优化：源码级优化器（Source Code Optimizer）会在源代码级别进行优化。由于在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码（Intermediate Code），它是语法树的顺序表示。比较常见的有三地址码 `x = y op z`。
-   代码生成：代码生成器（Code Generator）将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。
-   目标代码优化：目标代码优化器（Target Code Optimizer）对目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。

**汇编**过程相对于编译器来讲比较简单，每一个汇编语句几乎都对应一条机器指令，只是根据汇编指令和机器指令的对照表一一翻译就可以了。汇编过程将生成`.o`文件，相当于执行`$gcc –c hello.c –o hello.o`命令。

**链接**过程将许多`.o`文件链接起来，生成最终的可执行程序`a.out`。链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤。

## 第 3 章 目标文件里有什么

目标文件和可执行文件可以被看作同一种文件类型，在 Windows 下是 PE（Portable Executable），在 Linux 下是 ELF（Executable Linkable Format），它们都是 COFF（Common file format）格式的变种。除了可执行文件和目标文件，动态链接库（Windows 的.dll 和 Linux 的.so）及及静态链接库（Windows 的.lib 和 Linux 的.a）也按照可执行文件格式存储。

目标文件中的内容至少有编译后的机器指令代码、数据。除此之外，目标文件中还包括了链接时所须要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“节”（Section）的形式存储，有时候也叫“段”（Segment）。

<img src="img/3-1.png" height=400><img src="img/3-2.png" height=400>

如图，ELF 格式的可执行文件中，开头是一个“**文件头**”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息。紧接着是 ELF 文件各个段。接下来还包括一个**段表**（Section Table），段表是描述了文件中各个段在文件中的偏移位置及段的属性等信息的数组。

### 文件头

ELF 的文件头中定义了 ELF 魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI 版本、ELF 重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。

-   ELF 魔数：最开始的 4 个字节被称为魔数，所有 ELF 文件都有相同的标识码，分别为 0x7F、0x45、0x4c、0x46。

    _几乎所有可执行文件的开头几个字节都是魔数。_

-   文件机器字节长度：接下来的 1 个字节用来标识 ELF 文件的字长，，0x01 表示是 32 位；0x02 表示是 64 位。
-   数据存储方式：第 6 个字节表示字节序，规定该 ELF 是大端还是小端。
-   版本：第 7 个字节规定 ELF 文件的主版本号，一般是 1。
-   入口地址：规定 ELF 程序的入口虚拟地址。
-   段表的位置：记录了段表的开始位置在文件中的偏移。

### 代码和数据段

程序源代码编译后的机器指令经常被放在**代码段**（Code Section）里，代码段常见的名字有“.code”或“.text”；全局变量和局部静态变量数据经常放在**数据段**（Data Section），一般叫“.data”。C 语言的编译后执行语句都编译成机器代码，保存在 “.text” 代码段；已初始化的全局变量和局部静态变量都保存在 “.data” 段；未初始化的全局变量和局部静态变量一般放在一个叫 “.bss” 的段里，它为未初始化的变量预留位置，并没有内容，在文件中也不占用空间。

把程序的指令和数据的存放分开有许多好处：一方面是当程序被装载后，数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读，可以防止程序的指令被有意或无意地改写；另外一方面是指令区和数据区的分离有利于提高程序的局部性，有利于提高缓存的命中率；第三个原因，也是最重要的原因，就是当系统中运行着多个该程序的副本时，数据区域是私有的，但是指令区域可以是共享的，所以内存中只需要保存一份进程的指令部分。

ELF 文件中实际存在的就是“.text”、“.data”、“.rodata”和“.comment”这 4 个段。“.text”段存放指令的机器代码；“.data”段存放已初始化的全局变量和局部静态变量，未初始化的变量则声明在“.bbs”段中，不占用空间；“.rodata”段存放的是只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量；“.comment”段中存储的是编译器版本信息。

### 段表

段表（Section Header Table）是保存了 ELF 文件中各种段的基本属性的结构。段表是 ELF 文件中除了文件头以外最重要的结构，它描述了 ELF 的各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。

段表的结构比较简单，它是一个以“Elf32_Shdr”结构体为元素的数组。数组元素的个数等于段的个数，每个“Elf32_Shdr”结构体对应一个段。“Elf32_Shdr”又被称为段描述符（Section Descriptor）。结构体定义如下：

```c
typedef struct
{
    Elf32_Word sh_name;       // 段名
    Elf32_Word sh_type;       // 段类型
    Elf32_Word sh_flags;      // 标识位
    Elf32_Addr sh_addr;       // 段虚拟地址
    Elf32_Off sh_offset;      // 段偏移（在文件中的偏移）
    Elf32_Word sh_size;       // 段长度
    Elf32_Word sh_link;       // 段链接信息
    Elf32_Word sh_info;       // 段链接信息
    Elf32_Word sh_addralign;  // 段地址对齐
    Elf32_Word sh_entsize;    // Section Entry Size 项的长度
} Elf32_Shdr;
```

### 重定位表

链接器在处理目标文件时，须要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些重定位的信息都记录在 ELF 文件的重定位表里面，对于每个须要重定位的代码段或数据段，都会有一个相应的重定位表。

### 字符串表

因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。

### 符号表

在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。

符号是链接中的粘合剂，整个链接过程正是基于符号才能够正确完成。链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。

ELF 文件中的符号表往往是文件中的一个段，段名一般叫“.symtab”。符号表的结构是一个 Elf32_Sym 结构（32 位 ELF 文件）的数组，每个 Elf32_Sym 结构对应一个符号。结构体定义如下：

```c
typedef struct {
    Elf32_Word st_name;      // 符号名。这个成员包含了该符号名在字符串表中的下标。
    Elf32_Addr st_value;     // 符号对应的值
    Elf32_Word st_size;      // 符号大小。对于包含数据的符号，这个值是数据类型的大小。
    unsigned char st_info;   // 符号类型和绑定信息
    unsigned char st_other;  // 0
    Elf32_Half st_shndx;     // 符号所在的段
} Elf32_Sym;
```

_像 C++这样的后来设计的语言开始考虑到命名冲突问题，增加了名称空间（Namespace）的方法来解决多模块的符号冲突问题。_

### 调试信息

如果在编译时加上 -g 参数，就会发现，目标文件里多了很多 “debug” 相关的段，这些段中保存的就是调试信息。调试信息在目标文件和可执行文件中占用很大的空间，往往比程序的代码和数据本身大好几倍。

## 第 4 章 静态链接

### 空间与地址分配

对于链接器来说，整个链接过程中，它就是将几个输入目标文件加工后合并成一个输出文件。对于多个目标文件，链接器将相同性质的段合并到一起，比如将所有输入文件的“.text”合并到输出文件的“.text”段，接着是“.data”段、“.bss”段等。

为目标文件分配地址和空间有两个含义：第一个是在输出的可执行文件中的空间；第二个是在装载后的虚拟地址中的虚拟地址空间。对于有实际数据的段，比如“.text”和“.data”来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于“.bss”这样的段来说，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。

现代的链接器一般都采用一种叫两步链接（Two-pass Linking）的方法。第一步，**空间与地址分配**，扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。第二步，**符号解析与重定位**，使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。

VMA 表示 Virtual Memory Address，即虚拟地址。链接前后的程序中所使用的地址已经是程序在进程中的虚拟地址。在链接之前，目标文件中的所有段的 VMA 都是 0，因为虚拟空间还没有被分配，所以它们默认都为 0。

### 符号链接与重定位

### COMMON 块

### C++相关问题

### 静态库链接

### 连接过程控制

### BFD 库
